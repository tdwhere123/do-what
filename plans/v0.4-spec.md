# v0.4 — 记忆系统 执行规格

> 目标：两层记忆（系统 + 项目），Soul 页面升级为智能编辑器。
> 前提：v0.2 shared-config.ts 已建立，v0.3 Project 类型已就绪。
> 完成标志：`pnpm typecheck` 通过；Soul 页面显示并可编辑 system.md；新 session 的 prompt 前缀包含 system.md 摘要。

---

## 两层记忆

| 层 | 文件路径 | 作用 | 何时注入 |
|----|---------|------|---------|
| 系统记忆 | `~/.config/do-what/shared/system.md` | 用户偏好、沟通风格、长期目标 | 每次任何 session 启动时注入 prompt 前缀 |
| 项目记忆 | `<project_workdir>/AGENTS.md` | 技术栈、约定、当前进度 | 工具自己读（Claude Code/Codex/OpenCode 均支持），App 负责维护内容 |

---

## 新增 `packages/app/src/app/lib/memory.ts`

```ts
import { invoke } from "@tauri-apps/api/core";
import { isTauriRuntime } from "../utils";

const SYSTEM_MEMORY_PATH = "~/.config/do-what/shared/system.md";

// 读取 system.md（返回空字符串如不存在）
export async function readSystemMemory(): Promise<string>;

// 写入 system.md
export async function writeSystemMemory(content: string): Promise<void>;

// 读取项目 AGENTS.md
export async function readProjectMemory(workdir: string): Promise<string>;

// 写入项目 AGENTS.md
export async function writeProjectMemory(workdir: string, content: string): Promise<void>;

// 构造注入前缀（从 system.md 提取关键段落）
// 格式：简短摘要，不超过 500 chars
// 用于在每个 session prompt 前自动追加
export async function buildSystemMemoryPrefix(): Promise<string>;
```

**实现细节**：
- 读写通过 Tauri `fs` plugin 或已有的 `invoke("read_text_file")` / `invoke("write_text_file")`
- `buildSystemMemoryPrefix()` 直接返回整个 system.md 内容（截断到 500 chars），不需要 AI 提取

---

## 新增 `packages/app/src/app/lib/memory-extractor.ts`

```ts
import type { AgentRun } from "../state/sessions";
import type { RunEvent } from "./agent-output-parser";

export type MemoryCandidate = {
  content: string;        // 建议写入的内容
  targetLayer: "system" | "project";
  targetWorkdir?: string; // project layer 需要
  reason: string;         // 展示给用户的说明
};

// 从 session events 里提取候选记忆（简单规则，不调用 AI）
// 规则：
//   - 遇到 file_write 到配置文件（*.json, *.toml, *.yaml）→ 项目记忆候选
//   - 遇到 text 里包含"记住"、"always"、"never"、"prefer" 关键词 → 系统记忆候选
//   - 遇到 done 且 durationMs > 30000 → 可能有重要结果，提示用户记录
export function extractMemoryCandidates(
  run: AgentRun,
  options?: { maxCandidates?: number }
): MemoryCandidate[];
```

**注**：v0.4 的提取逻辑是基于规则的，不调用 AI。AI 提取留给后续版本。

---

## 修改 `packages/app/src/app/pages/soul.tsx`

重构 Soul 页面为三个区块：

### 区块 1：关于你（system.md）

```tsx
// 加载并展示 system.md 内容
// 使用已有的 LiveMarkdownEditor 组件（packages/app/src/app/components/live-markdown-editor.tsx）
// 保存时调用 writeSystemMemory()

<section>
  <h2>关于你</h2>
  <p class="text-sm text-gray-10">
    每次 session 启动时自动注入到 prompt 前缀。
  </p>
  <LiveMarkdownEditor
    value={systemMemoryContent()}
    onChange={handleSystemMemorySave}
    placeholder="写下你的偏好、工作方式、长期目标..."
  />
</section>
```

### 区块 2：当前项目（AGENTS.md）

```tsx
// 列出 projects store 里的项目
// 默认显示最近使用的项目的 AGENTS.md
// 有 project switcher dropdown

<section>
  <h2>当前项目</h2>
  <select value={activeProjectId()} onChange={...}>
    <For each={projects}>{(p) => <option value={p.id}>{p.name}</option>}</For>
  </select>
  <LiveMarkdownEditor
    value={projectMemoryContent()}
    onChange={handleProjectMemorySave}
    placeholder="技术栈、约定、当前进度..."
  />
  <p class="text-xs text-gray-10">上次更新: {formatRelativeTime(lastUpdatedAt())}</p>
</section>
```

### 区块 3：待记录（Memory Candidates）

```tsx
// 展示 memoryCandidates() 列表
// 每条候选：内容预览 + [写入] [忽略] 按钮

<section>
  <h2>待记录</h2>
  <Show when={memoryCandidates().length === 0}>
    <p class="text-sm text-gray-10">暂无待记录内容。</p>
  </Show>
  <For each={memoryCandidates()}>
    {(candidate) => (
      <div class="border rounded p-3">
        <p class="text-xs text-gray-10">{candidate.reason}</p>
        <pre class="text-sm mt-1">{candidate.content}</pre>
        <div class="flex gap-2 mt-2">
          <button onClick={() => handleAcceptCandidate(candidate)}>写入</button>
          <button onClick={() => handleDismissCandidate(candidate)}>忽略</button>
        </div>
      </div>
    )}
  </For>
</section>
```

---

## 修改 `packages/app/src/app/lib/shared-config.ts`

在 `buildPromptPrefix()` 里加入 system.md 内容：

```ts
// 改前：只注入 rules.md
// 改后：rules.md + system.md 合并注入

export async function buildPromptPrefix(): Promise<string> {
  const [rules, systemMemory] = await Promise.all([
    readRulesContent(),
    readSystemMemory(),
  ]);

  const parts: string[] = [];
  if (systemMemory.trim()) {
    parts.push(`<system_memory>\n${systemMemory.trim()}\n</system_memory>`);
  }
  if (rules.trim()) {
    parts.push(`<rules>\n${rules.trim()}\n</rules>`);
  }
  return parts.length ? parts.join("\n\n") + "\n\n" : "";
}
```

---

## 修改 `packages/app/src/app/context/session.ts`

在 session 结束后（AgentRun status 变为 "done" 或 "error"）触发 memory extraction：

```ts
// 在监听 agent run 状态变化的 effect 里：
createEffect(() => {
  const runs = agentRuns;
  runs.forEach((run) => {
    if (run.status === "done" && !run._memoryCandidatesExtracted) {
      const candidates = extractMemoryCandidates(run);
      if (candidates.length) {
        addMemoryCandidates(candidates);
      }
      updateAgentRun(run.id, { _memoryCandidatesExtracted: true } as any);
    }
  });
});
```

（`_memoryCandidatesExtracted` 是运行时字段，不需要持久化）

---

## 验证检查清单

- [ ] `pnpm typecheck` 通过
- [ ] Soul 页面显示三个区块
- [ ] 编辑 system.md 区块并保存，文件实际被写入（用文件管理器验证）
- [ ] 切换项目显示对应 AGENTS.md
- [ ] 新 session 的 prompt 前缀里包含 system.md 内容（console.log 验证）
- [ ] Session 结束后，如果有候选内容，Soul 页面的"待记录"区块显示提示
