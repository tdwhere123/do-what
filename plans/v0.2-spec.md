# v0.2 — 统一 Agent 运行时 执行规格

> 目标：让 Claude Code CLI 和 Codex CLI 作为并列引擎运行，App 负责启动进程、捕获 stdout、渲染结构化输出卡片。
> 完成标志：`pnpm typecheck` 通过；Settings > Runtimes 显示引擎状态；可以用 Claude Code 发起 Quick Chat。

---

## 背景

三个引擎平等对待：
- **OpenCode**：现有路径不动（HTTP server + SDK）
- **Claude Code**：`claude -p "<prompt>" --output-format stream-json [--cwd <dir>]`
- **Codex**：优先 `codex "<prompt>" [--cwd <dir>]`，无 CLI 时 fallback 到 OpenAI Responses API

两种 Session 类型：
- **Quick Chat**：无 workdir，轻量，随时对话
- **Agent Run**：有 workdir，长时运行，有文件操作

---

## 新增文件

### A. `packages/app/src/app/lib/agent-output-parser.ts`

```ts
// RunEvent union
export type RunEvent =
  | { type: "text";       content: string }
  | { type: "tool_call";  tool: string; args: Record<string, unknown>; result?: string }
  | { type: "file_read";  path: string; preview?: string }
  | { type: "file_write"; path: string; diff?: string }
  | { type: "bash";       command: string; output: string; exitCode?: number }
  | { type: "code";       language: string; content: string }
  | { type: "error";      message: string }
  | { type: "done";       exitCode: number; durationMs: number };

// Claude Code 的 --output-format stream-json 每行是一个 JSON 对象
// 参考字段：type ("assistant"|"result"|"system"), message.content[], subtype
export function parseClaudeCodeChunk(raw: string): RunEvent[];

// Codex 输出是纯文本，用正则匹配常见模式
export function parseCodexChunk(raw: string): RunEvent[];

// 300ms debounce flush，避免频繁更新 UI
export class OutputBuffer {
  constructor(onFlush: (events: RunEvent[]) => void, debounceMs?: number);
  push(chunk: string, runtime: "claude-code" | "codex"): void;
  flush(): void;
  destroy(): void;
}
```

**parseClaudeCodeChunk 实现逻辑**：
1. 按 `\n` 分割，逐行尝试 `JSON.parse()`
2. 若 parse 失败 → `{ type: "text", content: line }`
3. 若 `obj.type === "assistant"` → 从 `obj.message.content` 提取文本/tool_use
4. 若 `obj.type === "result"` 且 `obj.subtype === "success"` → `{ type: "done", exitCode: 0, durationMs: ... }`
5. 若 `obj.type === "result"` 且 error → `{ type: "error", message: obj.error }`

**parseCodexChunk 实现逻辑**：
- 正则 `\$ (.+)\n([\s\S]*?)(?=\$|$)` → bash card
- 正则 `` ```(\w+)\n([\s\S]+?)``` `` → code card
- 其余 → text card

---

### B. `packages/app/src/app/lib/shared-config.ts`

```ts
import { invoke } from "@tauri-apps/api/core";

export type McpEntry = {
  name: string;
  command: string[];
  env?: Record<string, string>;
};

export type SharedConfig = {
  rulesPath: string;      // ~/.config/do-what/shared/rules.md
  mcpServers: McpEntry[]; // ~/.config/do-what/shared/mcp.json
  skillsDir: string;      // ~/.config/do-what/shared/skills/
};

// 读取配置（不存在时返回 defaults）
export async function readSharedConfig(): Promise<SharedConfig>;

// 写入配置
export async function writeSharedConfig(cfg: Partial<SharedConfig>): Promise<void>;

// 读取 rules.md 内容
export async function readRulesContent(): Promise<string>;

// 写入 rules.md
export async function writeRulesContent(content: string): Promise<void>;

// 构造启动参数前缀（注入 system memory 到 prompt）
export async function buildPromptPrefix(): Promise<string>;
```

**注**：读写通过 Tauri `invoke("read_text_file", { path })` / `invoke("write_text_file", { path, content })`，使用 `packages/desktop/src-tauri/src/commands/misc.rs` 里已有的文件命令（如有），或直接用 `tauri-plugin-fs`。

---

### C. `packages/app/src/app/components/agent-run/` 目录

新建以下 7 个文件：

#### `index.tsx` — 主容器

```tsx
import { For } from "solid-js";
import type { RunEvent } from "../../lib/agent-output-parser";
// ... 各 card 组件

type Props = {
  events: RunEvent[];
  status: "running" | "done" | "error" | "aborted";
};

export default function AgentRunView(props: Props) {
  return (
    <div class="flex flex-col gap-2 p-4 overflow-y-auto">
      <For each={props.events}>
        {(event) => <EventCard event={event} />}
      </For>
    </div>
  );
}
```

#### `text-card.tsx`
普通文字，用已有的 `marked` 库做 markdown 渲染。

#### `tool-call-card.tsx`
可折叠卡片，显示工具名 + 参数 JSON + 结果。默认折叠，点击展开。

#### `bash-card.tsx`
命令行样式：`$ command` + stdout，monospace 字体，深色背景。

#### `file-write-card.tsx`
显示文件路径 + diff 内容（如有）。diff 格式：绿色加行，红色删行。

#### `code-card.tsx`
代码块，语法高亮（用 `<pre><code>` 即可，不需要额外库）。

#### `error-card.tsx`
红色背景，显示错误信息。

#### `done-banner.tsx`
完成横幅：绿色/红色，显示耗时 + 退出码。

---

### D. `packages/desktop/src-tauri/src/commands/agent_run.rs`

```rust
use std::collections::HashMap;
use std::process::Stdio;
use std::sync::{Arc, Mutex};
use tauri::{AppHandle, Emitter};
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::process::Command;

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub enum AgentRuntime {
    ClaudeCode,
    Codex,
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AgentRunConfig {
    pub mcp_config_path: Option<String>,
    pub rules_prefix: Option<String>,
}

#[derive(serde::Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AgentRunChunk {
    pub chunk: String,
    pub timestamp: u64,
}

// 全局运行中进程 map：run_id -> abort handle
type RunMap = Arc<Mutex<HashMap<String, tokio::task::AbortHandle>>>;

// 在 AppState 里注册（或用 tauri::State<RunMap>）
// 简化版：用全局 static

#[tauri::command]
pub async fn agent_run_start(
    app: AppHandle,
    run_id: String,
    runtime: AgentRuntime,
    prompt: String,
    workdir: Option<String>,
    config: AgentRunConfig,
) -> Result<(), String> {
    let event_name = format!("agent-run-output/{}", run_id);

    let mut cmd = match runtime {
        AgentRuntime::ClaudeCode => {
            let mut c = Command::new("claude");
            c.args(["-p", &prompt, "--output-format", "stream-json"]);
            if let Some(ref dir) = workdir {
                c.args(["--cwd", dir]);
            }
            c
        }
        AgentRuntime::Codex => {
            let mut c = Command::new("codex");
            c.arg(&prompt);
            if let Some(ref dir) = workdir {
                c.args(["--cwd", dir]);
                c.current_dir(dir);
            }
            c
        }
    };

    cmd.stdout(Stdio::piped()).stderr(Stdio::piped());

    let mut child = cmd.spawn().map_err(|e| e.to_string())?;
    let stdout = child.stdout.take().ok_or("no stdout")?;

    let app_clone = app.clone();
    let run_id_clone = run_id.clone();

    tokio::spawn(async move {
        let reader = BufReader::new(stdout);
        let mut lines = reader.lines();

        while let Ok(Some(line)) = lines.next_line().await {
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64;

            let _ = app_clone.emit(&event_name, AgentRunChunk {
                chunk: line,
                timestamp: now,
            });
        }

        let _ = child.wait().await;

        let _ = app_clone.emit(&event_name, AgentRunChunk {
            chunk: r#"{"type":"done","exitCode":0}"#.to_string(),
            timestamp: 0,
        });
    });

    Ok(())
}

#[tauri::command]
pub async fn agent_run_abort(run_id: String) -> Result<(), String> {
    // TODO: 从全局 map 里找到对应 handle，调用 abort()
    // 简化版先返回 Ok，v0.2 后期补完
    Ok(())
}

#[tauri::command]
pub async fn check_runtime_available(runtime: AgentRuntime) -> Result<String, String> {
    let bin = match runtime {
        AgentRuntime::ClaudeCode => "claude",
        AgentRuntime::Codex => "codex",
    };

    let output = Command::new(bin)
        .arg("--version")
        .output()
        .await
        .map_err(|_| format!("{} not found in PATH", bin))?;

    let version = String::from_utf8_lossy(&output.stdout).trim().to_string();
    Ok(version)
}
```

**注册**：在 `packages/desktop/src-tauri/src/commands/mod.rs` 里加入：
```rust
pub mod agent_run;
```

在 `lib.rs` 的 `.invoke_handler(...)` 里加入：
```rust
commands::agent_run::agent_run_start,
commands::agent_run::agent_run_abort,
commands::agent_run::check_runtime_available,
```

`Cargo.toml` 加入 `tokio` 依赖（如尚未有）：
```toml
tokio = { version = "1", features = ["full"] }
```

---

## 修改已有文件

### E. `packages/app/src/app/state/sessions.ts`

在文件末尾追加以下类型（不修改现有类型）：

```ts
import type { RunEvent } from "../lib/agent-output-parser";

export type AgentRunStatus = "running" | "done" | "error" | "aborted";

export type AgentRunType = "quick-chat" | "agent-run";

export type AgentRun = {
  id: string;
  runtime: "claude-code" | "codex";
  type: AgentRunType;
  prompt: string;
  workdir?: string;
  title: string;
  status: AgentRunStatus;
  events: RunEvent[];
  startedAt: number;
  endedAt?: number;
  projectId?: string;
  parentSessionIds?: string[];
};
```

并创建一个简单的 store（Solid store）管理 AgentRun 列表：

```ts
import { createStore } from "solid-js/store";

const [agentRuns, setAgentRuns] = createStore<AgentRun[]>([]);

export function useAgentRuns() {
  return { agentRuns, setAgentRuns };
}

export function addAgentRun(run: AgentRun) {
  setAgentRuns((prev) => [run, ...prev]);
}

export function updateAgentRun(id: string, patch: Partial<AgentRun>) {
  setAgentRuns((run) => run.id === id, patch);
}

export function appendRunEvent(id: string, event: RunEvent) {
  setAgentRuns(
    (run) => run.id === id,
    "events",
    (events) => [...events, event]
  );
}
```

---

### F. `packages/app/src/app/lib/tauri.ts`

在文件末尾追加：

```ts
import type { AgentRuntime, AgentRunConfig } from "../state/sessions";

export async function agentRunStart(params: {
  runId: string;
  runtime: AgentRuntime;
  prompt: string;
  workdir?: string;
  config: AgentRunConfig;
}): Promise<void> {
  return invoke("agent_run_start", {
    runId: params.runId,
    runtime: params.runtime,
    prompt: params.prompt,
    workdir: params.workdir ?? null,
    config: params.config,
  });
}

export async function agentRunAbort(runId: string): Promise<void> {
  return invoke("agent_run_abort", { runId });
}

export async function checkRuntimeAvailable(
  runtime: "claude-code" | "codex"
): Promise<string> {
  return invoke("check_runtime_available", { runtime });
}
```

---

### G. `packages/app/src/app/pages/settings.tsx`

在 `SettingsTab` 类型和 Settings 页面里加入 `"runtimes"` tab：

**`types.ts` 改动**：
```ts
// 改前
export type SettingsTab = "general" | "workspace" | "model" | "advanced" | "debug";
// 改后
export type SettingsTab = "general" | "workspace" | "model" | "runtimes" | "advanced" | "debug";
```

**`settings.tsx` 加入 Runtimes 面板**，包含：

1. **Claude Code 卡片**
   - 状态显示：调用 `checkRuntimeAvailable("claude-code")` → 显示版本号或 "Not found"
   - Check 按钮：点击重新检查
   - 说明：`Requires 'claude login' on this machine`

2. **Codex 卡片**
   - 状态显示：调用 `checkRuntimeAvailable("codex")` → 显示版本号或显示 "Using OpenAI API fallback"
   - 按钮：Check CLI / Configure API Key

3. **Shared Config 区块**
   - rules.md 编辑入口：点击打开 `LiveMarkdownEditor`（已有组件）
   - MCP servers 管理：简单列表 + 添加按钮（v0.3 完善）

---

### H. `packages/app/src/app/components/session/composer.tsx`

在 composer 底部工具栏加入**运行时选择器**：

```tsx
// 新增 signal
const [selectedRuntime, setSelectedRuntime] = createSignal<"opencode" | "claude-code" | "codex">("opencode");
const [selectedWorkdir, setSelectedWorkdir] = createSignal<string | null>(null);

// UI：底部工具栏右侧加一个小 dropdown
<select
  value={selectedRuntime()}
  onChange={(e) => setSelectedRuntime(e.target.value as any)}
  class="text-xs border rounded px-1 py-0.5"
>
  <option value="opencode">OpenCode</option>
  <option value="claude-code">Claude Code</option>
  <option value="codex">Codex</option>
</select>

// 选了非 opencode 且想选 workdir 时，显示一个目录选择按钮
<Show when={selectedRuntime() !== "opencode"}>
  <button onClick={handlePickWorkdir} class="text-xs text-gray-10 underline">
    {selectedWorkdir() ? selectedWorkdir() : "Pick workdir (optional)"}
  </button>
</Show>
```

`handlePickWorkdir` 用 `@tauri-apps/plugin-dialog` 的 `open({ directory: true })` 选目录。

**发送逻辑**：
- `selectedRuntime() === "opencode"` → 走现有 `createSessionAndOpen()` 路径
- 否则 → 生成 `uuid`，调用 `agentRunStart()`，并把 AgentRun 写入 store

---

### I. `packages/app/src/app/components/session/sidebar.tsx`

在 session 列表条目里，加入 runtime badge：

```tsx
// 在 session item 里
<Show when={run.runtime === "claude-code"}>
  <span class="text-[10px] font-mono bg-orange-3 text-orange-11 px-1 rounded">CC</span>
</Show>
<Show when={run.runtime === "codex"}>
  <span class="text-[10px] font-mono bg-green-3 text-green-11 px-1 rounded">CX</span>
</Show>
```

在 AgentRun 的 status 点：
```tsx
// running → 橙色/绿色闪烁点
// done → 灰色点
// error → 红色点
```

侧边栏需要同时渲染两个列表：
1. 现有 OpenCode sessions（不变）
2. `agentRuns` store 里的 AgentRun（新增，排在上方或混合排序按 `startedAt` 倒序）

---

## 验证检查清单

- [ ] `pnpm typecheck` 通过
- [ ] Settings > Runtimes tab 存在，显示 Claude Code 和 Codex 状态
- [ ] Composer 底部有运行时 dropdown
- [ ] 选 Claude Code + 发 prompt → 侧边栏出现带 CC badge 的条目
- [ ] AgentRunView 渲染 text-card / bash-card / done-banner
- [ ] OpenCode 现有功能完全不受影响
